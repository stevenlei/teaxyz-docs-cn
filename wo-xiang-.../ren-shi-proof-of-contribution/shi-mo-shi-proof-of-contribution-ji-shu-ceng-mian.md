# 什么是 Proof of Contribution？（技术层面）

> 此版本为社区翻译的非官方版本，仅供参考之用。请以官方文档为准。\
> 原文：[https://docs.tea.xyz/tea/i-want-to.../learn-about-proof-of-contribution/what-is-proof-of-contribution-technical](https://docs.tea.xyz/tea/i-want-to.../learn-about-proof-of-contribution/what-is-proof-of-contribution-technical)

Proof of Contribution 通过将开源软件项目、它们的版本和它们的依赖项建模为节点和边来测量项目影响。该算法基于 的基础，使用概率分布为节点分配分数——teaRank 分数，代表随机导航到特定节点的可能性。

Proof of Contribution 使用各种输入和反垃圾邮件机制来准确衡量软件项目的影响。为了输出 teaRank 分数，算法可能会考虑软件项目的这些方面：

* 项目影响力，使用项目的依赖数作为代理
* 项目随时间的影响力，使用项目的年龄作为代理

### 数据来自哪里？

项目的 teaRank 是衡量其在开源软件生态系统中影响力的指标，这个值在很大程度上取决于它的依赖数。然而，在不断扩展的软件开发领域中，跟踪所述依赖项的效率和可靠性可能非常困难。

Proof of Contribution 采用一种革命性方法，通过深入探索项目生态系统内错综复杂的依赖关系、依赖项和相关性来实现这一点。Proof of Contribution 使用一种算法，从包管理器检索项目的依赖项和依赖数的数据。然后，该数据被相关联，并被 Proof of Contribution 算法用来计算项目的 teaRank。

我们将在 _**tea**_ 协议 V1 中支持的包管理器包括：

* crates
* npm
* pkgx
* hombrew
* pypi
* apt-get
* rubygems

#### 数据收集和处理如何工作？

Proof of Contribution 从包管理器源数据，这些包管理器将项目列在其注册表中。通过从多个包管理器获取数据，我们可以在一定的准确度内确定一个项目对整个开源软件生态系统的影响。

以下是算法工作方式的高级步骤说明：

1. 查询包管理器：Proof of Contribution 首先每天查询包管理器注册表，收集项目及其依赖项的信息。
2. 查找并索引项目：一旦找到项目，Proof of Contribution 将项目的元数据（包括依赖项和依赖项）添加到其数据库并对其进行索引，以便以后查询。
3. 将项目添加到 _**tea**_ 图中：Proof of Contribution 构建了一个全面的 OSS 项目图，绘制了项目及其依赖项之间的关系。

使用内置图表，Proof of Contribution 可以将传入关系分类为依赖项，将传出关系分类为依赖项。然后 Proof of Contribution 算法使用这些数据来计算项目的 teaRank。下图显示 A 依赖于 B、D 和 F，而其他所有项目依赖于 A 或彼此。

<figure><img src="https://lh7-us.googleusercontent.com/BJO920KWVlXK3WY8E4aooYJbDTHhtQTz5AsepzGFgRcBqby2rTPKD3kQQBKdMu9ZSnw4ZGXrt4t-MSkjrCX1ruz7n5BZjhkSi4gW9gVZ9GF356jrCpLkTuSeNZcUdU9DRYDWf_3A_hdwRiPTjL4_zEw" alt=""><figcaption></figcaption></figure>

### 测量累积影响

Proof of Contribution 评估 OSS 生态系统中每个项目的影响如何随时间变化，并提供分析，展示哪些 OSS 项目持续提供实质性价值。为此，它将开源图分成不同的时间段，或 delta (δ)。

对于每个时间段，算法使用先前时期的信息来计算每个项目的 teaRank，以通知当前时期的 teaRank 计算。这提供了项目重要性的细致且长期的历史记录，并在确定其影响时纳入了软件项目的所有版本。Proof of Contribution 用于其分析的 δ 时间段的数量是一个重要的设计

选择。使用过少的 δ 间隔可能无法量化 OSS 项目的全部影响，而使用过多的间隔可能会显著阻碍新建立的项目。使用过多的 δ 间隔还会通过要求 _**tea**_ 协议 δ 次重建整个开源图以生成 teaRank 来创建计算负担。

### 抗垃圾邮件

Proof of Contribution 基于两个主要框架——树攻击和宽度攻击来抵抗垃圾邮件。采取这种方法来对抗垃圾邮件是有效的，因为开源软件的垃圾邮件技术经常涉及劫持现有软件项目或创建包含恶意代码的复杂依赖网络。

#### 树攻击

想象一个软件依赖者的金字塔。恶意行为者创建一长串依赖项目，人为地夸大链中每个项目的重要性，目的是为了不公平地为每个软件依赖项生成奖励。

#### 宽度攻击

想象一个被许多依赖项目包围的单个软件项目。恶意行为者创建大量虚假依赖项，人为地夸大中心项目的影响力。

#### 对抗树攻击和宽度攻击

Proof of Contribution 通过量化软件项目追溯到没有依赖项的项目的最长依赖路径——称为其树限制——来部分抵御树攻击。算法通过计算软件项目的宽度限制，即其软件依赖项的总数，部分抵御宽度攻击。Proof of Contribution 在 δ 时间间隔内持续监控树和宽度限制，以识别——并可能将其标记为垃圾邮件——对 OSS 生态系统中软件项目位置的任何突然变化。

Proof of Contribution 还通过使用高级符号 Kappa，或 κ，来抵御树攻击，κ 用于限制开源软件项目的影响力。κ 是自我影响的度量，源自 Proof of Contribution 使用的自环——从节点（OSS 项目）到它们自己的边。Kappa 的值范围从 0 到 1。

### κ (Kappa)

我们基于影响力限制的概念设计了 κ，以使垃圾邮件发送者难以利用排名系统，即使他们通过现有或新项目控制了网络中的大部分项目。

这种方法包括在图中的每个项目上引入自环，并分配 0 到 1 之间的边权重，我们将其表示为 κ。所有其余每个项目的边被重新索引，使得它们的边权重总和为 1 - κ。我们有效地限制了一个项目到另一个项目的排名流动。这种机制有两个效果：

1. 通过在依赖图深处的项目中插入依赖项来减轻网络垃圾邮件的潜力。
2. 简化问题，以允许对有影响力的基础项目公平地进行 teaRank 评分，即位于依赖堆栈底部的项目。

在设计 κ 的值时，我们考虑了树垃圾邮件网络的影响和建立限制垃圾邮件网络可能获得不当影响的必要性。κ 充当一个可调工具，用于微调项目对自身的影响，既防止垃圾邮件又准确衡量开源项目的影响。

### δ (Delta)

虽然 κ 解决了项目在直接邻域中的影响，δ 专注于随时间的影响。它允许 teaRank 捕获随着开源生态系统的增长而不断变化的项目影响。

我们将 δ 定义为我们将迭代构建开源图的时间段。在每个时期，我们将使用前一时期的分数作为当前时期的边权重来计算 teaRank 分数。本质上，我们捕获了项目随时间的累积价值和影响，提供了它们重要性的全面视图。

选择最佳的 δ 值需要一些权衡。较低的 δ 值表示图以更频繁的间隔构建，允许 teaRank 快速适应并识别在不同时期持续表现出显著影响的项目。它还计算密集，并涉及多次图重建。较高的 δ 值则较少频繁地构建图，并允许新项目在每个周期内有平等的机会展示其价值。

### 平衡 κ 和 δ

过多地将计算权力赋予 κ 可能会使奖励分配过于偏向于已建立的开源软件项目——而过分依赖 δ 可能会阻碍创新，不利于刚刚出现的 OSS 项目。Proof of Contribution 算法被校准以避免这些陷阱，同时以资源高效的方式运行。

δ 和 κ 的初始值是通过进行广泛的数据分析定义的，但可以调整。从 _**tea**_ 的激励测试网阶段开始，_**tea**_ 开发人员将密切监控 teaRank 的性能，并可能向 teaDAO 推荐调整 δ 或 κ。

虽然 teaRank 参数是必要的，但仅依赖它们可能不足够。过度调整算法以对抗垃圾邮件攻击可能会扭曲每个项目的真实影响。为了找到正确的平衡，我们开发了两种策略——限制和奖励阈值——它们不仅有助于检测垃圾邮件，还为恶意行为者操纵系统以获得不应得的奖励引入成本。

### 压缩

为了减少最依赖和最少依赖项目之间的差异，_**tea**_ 协议通过执行一些操作来压缩原始 teaRank 分数。这些操作包括将原始 teaRank 分数转换为其对数等价物，这显著减少了差异，同时保持了该分数的相对大小。通过这种压缩，两个项目之间的差异从 2,500,000 倍变为 100,000 倍。

使用这种压缩算法，_**tea**_ 协议可以区分贡献者和依赖项较少的小众项目和具有大量依赖项和贡献者的高使用项目。通过这种区分，_**tea**_ 协议将 teaRank 奖励阈值分配为高于小众项目的值，并最小化垃圾邮件奖励。理想的阈值消除了分发给恶意行为者的任何代币奖励，同时最小化了合法、有影响力的项目丢失的奖励。

### 奖励阈值和限制

Proof of Contribution 使用阈值和限制的组合来进一步增强其对垃圾邮件的抵抗力。算法的阈值和限制机制围绕项目的 teaRank 分数展开。

* teaRank 分数阈值 - _**tea**_ 协议使用 Proof of Contribution 根据治理定义的阈值仅计算并分配 teaRank 奖励给具有高于该阈值的 teaRank 分数的注册 OSS 项目。
* teaRank 分数限制 - Proof of Contribution 应用边权重并使用自环来建立软件项目可以获得的 teaRank 分数的上限。

通过 _**tea**_ 协议注册的软件项目受益于 Proof of Contribution 对阈值和限制的使用，这允许 TEA 代币公平地分配给只有重大影响的 OSS 项目。teaRank 分数阈值阻止垃圾邮件发送者，而 teaRank 分数限制限制了垃圾邮件项目获得不应得奖励的能力。使用阈值和限制还有助于检测垃圾邮件。

Proof of Contribution 旨在将 teaRank 分数阈值设置为准确的水平，以消除对恶意行为者的代币奖励分配，同时最小化具有低于该阈值的 teaRank 分数的合法、有影响力的项目的实例。该算法旨在将 teaRank 分数限制设置为同时奖励长期存在、有影响力的 OSS 项目并欢迎重要的新项目加入 OSS 生态系统的水平。
